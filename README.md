Следует написать бэкдор-сервер и клиент с помощью голых сокетов (socket)

**Сервер**

Сервер умеет выполнять одну команду, которую ему шлёт клиент:

Отдавать клиенту файл по запрошенному пути (например, ```/home/someuser/somefile```).

Бэкдор никогда не должен падать, поэтому любые ошибки доступа, открытия или существования

файла нужно отправлять на клиент, но не в коем случае не падать.

**Клиент**

Клиент получает от пользователя команды. Их две:

* ```get /home/user/something``` просит сервер (бэкдор) скачать файл по пути. Если файла нет,

он не может быть открыт или ещё что-то, клиент уведомляет пользователя об этом. Файл качается

в базу данных (можно использовать, например, [shelve](https://docs.python.org/3/library/shelve.html) или даже SQLite).

Предусмотреть хитрые ситуации: если файл раньше был в нашей БД и снова качается — перезаписывать старый.

Если файл раньше был в БД, а теперь недоступен для скачивания — оставить старую версию и уведомить пользователя

* ```cp /home/user/something /local/path/to/something``` вытаскивает из БД файл ```/home/user/something```

(либо прежде качает его, если файла в БД нет) и сохраняет его на машине клиента по пути ```/local/path/to/something```.

Поиск файла в БД логично делать за O (1) или за O (logN) время, но точно не за O (N). Если файла нет в БД и он не может быть скачан, то смотри в команду get, там написано, что пользователя нужно уведомить. И в БД, конечно же, записывать нечего, поэтому ничего не записывать.

IP адрес/порт подключения к бэкдору следует указывать либо в input (), либо через sys.argv. Команды отдаются через input ()

**Подсказка:** возможно, вам поможет модуль struct. Вам может показаться, что использовать модуль

pickle очень даже удобно. Да, это так. Нет, его нельзя для этого использовать (потому что небезопасно).

**Усложнение:**
Чтобы сервер был написан на async/await и мог принимать сколько угодно клиентов